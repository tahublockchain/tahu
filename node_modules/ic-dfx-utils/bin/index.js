#!/usr/bin/env node

import React, { useEffect, useState, useRef, useCallback } from "react"
import { render, Text } from "react-17-ink"
import util from "util"
import { exec as x } from "child_process"
import fs from "fs"
import path from "path"
import chokidar from "chokidar"
import spinners from "cli-spinners"

const appDirectory = fs.realpathSync(process.cwd())

const dfxJson = JSON.parse(fs.readFileSync(path.resolve(appDirectory, "dfx.json")))

const exec = util.promisify(x)

let canisters = Object.entries(dfxJson.canisters).filter(([key, value]) => key !== "assets")

const Spinner = ({ type = "dots" }) => {
  const [frame, setFrame] = useState(0)
  const spinner = spinners[type]

  useEffect(() => {
    const timer = setInterval(() => {
      setFrame(previousFrame => {
        const isLastFrame = previousFrame === spinner.frames.length - 1
        return isLastFrame ? 0 : previousFrame + 1
      })
    }, spinner.interval)

    return () => {
      clearInterval(timer)
    }
  }, [spinner])

  return React.createElement(Text, {}, spinner.frames[frame])
}

// let n = 0
const Output = () => {

  const [status, setStatus] = useState("loading")
  const [output, setOutput] = useState("")
  const ctrl = useRef(new AbortController())

  const [queued, setQueued] = useState(true)
  const [safe, setSafe] = useState(true)

  const build = async () => {
    // n++
    // let num = n
    setSafe(false)
    if (status === "loading") {
      // setOutput(o => o + `aborted${num}`)
      ctrl.current.abort()
    }

    try {
      // setOutput("")
      setStatus("loading")

      let ac = new AbortController()
      ctrl.current = ac

      // setOutput(o => o + ` preBuild${num}`)
      setOutput("Building canisters...")
      const pBuild = await exec(
        `dfx build`,
        { signal: ac.signal },
      )

      // setOutput(o => o + ` preInstall${num}`)
      setOutput("Installing canisters...")
      const pInstall = await exec(
        `dfx canister install ${canisters.map(([key, _]) => key).join(" ")} --mode='reinstall'`,
        { signal: ac.signal },
      )

      setOutput("")
      setQueued(false)
      setSafe(true)
      setStatus("finished")
    } catch (e) {
      /**
       * Quick hack to ignore the error that occurs when aborting
       */
      const ignore = e.stderr.includes("Permission denied (os error 13)") || e.name === "AbortError"
      if (!ignore) {
        setStatus("error")
      } else {
        // setOutput(o => o + ` AbortError${num}`)
        setOutput(e.stderr)
      }
      setSafe(true)
    }
  }

  useEffect(() => {
    if (queued && safe) {
      build()
    }
  }, [queued, safe])

  useEffect(() => {
    chokidar.watch("./src/backend").on("all", async (event, path) => {
      setQueued(true)
    })
  }, [])

  if (status === "loading") {
    return [
      React.createElement(Text, { color: "#3babe2", key: "text" }, [
        React.createElement(Spinner, { type: "dots", key: "spinner" }, ""),
        React.createElement(Text, { color: "#3babe2", key: "text" }, " " + output),
      ]),
    ]
  }
  if (status === "finished") {
    return React.createElement(Text, { color: "green" }, "âˆž Build successful!" + output)
  }
  if (status === "error") {
    return React.createElement(Text, { color: "#ee1f7a" }, output)
  }
}

render(React.createElement(Output, {}, null))